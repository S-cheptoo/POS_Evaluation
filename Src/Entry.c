/**
 * Entry.c
 *
 * !!!WARNING!!!
 * !This template file is compatible with SDK version >= 9.16
 * !!!WARNING!!!
 *
 * Application entry point.
 * This file was automatically generated by IngeDev and must be filled out
 * by the developer.
 *
 * Purpose:
 *
 * Each time Manager calls an application, it generates only one service
 * call that reaches your application main with the corresponding service
 * number.
 *
 * List of routines in file:
 * - give_your_domain: Return application domain.
 * - after_reset: Application reset processing.
 * - is_name: Report application name to Manager.
 * - is_state: Return application status (initialize or not).
 * - idle_message: Dedicated to display idle message.
 * - more_function: Dedicated to navigation menus.
 * - keyboard_event: Return key pressed.
 * - state: Print terminal content.
 * - consult: Print daily totals.
 * - mcall: Print call schedule.
 * - is_time_function: Need pheripherals at the next call time_function()
 * - time_function: Allow automatic execution of periodic functions.
 * - is_change_init: Conditions for changing manager parameters?
 * - modif_param: Manager reports parameters changing.
 * - is_evol_pg: Conditions for application downloading?
 * - is_delete: Conditions for application deletion?
 * - file_received: Manager reports parameters file received from LLT.
 * - message_received: Inter application messaging.
 * - is_card_specific: Card needs a specific process?
 * - card_inside: Transaction in progress for a specific card.
 * - is_for_you_before: Is chip card as an ISO 7816-3?
 * - is_for_you_after: recognize mag, smc or man card in order to be a candidate.
 * - give_interface: Services registration and priority.
 * - entry: Call by OS for recording services and opening DLL(s).
 */

#include <sdk_tplus.h>
#include "Menu.h"

//+++++++++++++ Macros & preprocessor definitions ++++++++++++++

#define __ENTER_KEY     -1
#define __BACK_KEY      -2
#define __EXIT_KEY      -3

#define NUMBER_OF_ITEMS(a) (sizeof(a)/sizeof((a)[0]))

// Services priority
// =================
// According to the Telium development rules all services registered from the
// Telium application to the Telium manager must have priority from 150 (0x96) to 255 (0xFF).
#define SERVICES_LOW_PRIORITY       150 + 30 // For all services except idle_message,
#define SERVICES_HIGH_PRIORITY      150 + 10 //      priority => 150 highest and 255 lowest
#define IDLE_LOW_PRIORITY           150 + 10 // For idle_message,
#define IDLE_HIGH_PRIORITY          150 + 30 //      priority => 150 lowest and 255 highest
#define SERVICES_DEFAULT_PRIORITY   150 + 20

//++++++++++++++++++++++ Global variables ++++++++++++++++++++++
static Telium_service_desc_t Services[] =
{
    { 0, GIVE_YOUR_DOMAIN, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, AFTER_RESET, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_NAME, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_STATE, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IDLE_MESSAGE, (Telium_callback)Main, (unsigned char)IDLE_HIGH_PRIORITY },
    { 0, MORE_FUNCTION, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, KEYBOARD_EVENT, (Telium_callback)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, STATE, (Telium_callback)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, CONSULT, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, MCALL, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_TIME_FUNCTION, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, TIME_FUNCTION, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_CHANGE_INIT, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, MODIF_PARAM, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_EVOL_PG, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_DELETE, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, FILE_RECEIVED, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, MESSAGE_RECEIVED, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_CARD_SPECIFIC, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, CARD_INSIDE, (Telium_callback)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, IS_FOR_YOU_AFTER, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, DEBIT_NON_EMV, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY }
//    { 0, GIVE_YOUR_SPECIFIC_CONTEXT, (Telium_callback)Main, (unsigned char)SERVICES_HIGH_PRIORITY }
};

typedef struct Params
{
    char Old_Date[24+1];
    char Old_FmtDate[24+1];
    char Old_Language[24+1];
    char Old_Pabx[24+1];
    char Old_PPad[24+1];
    char Old_PPadType[24+1];
    char Old_ISOreader[24+1];
    char Old_TMSaccess[24+1];
} S_PARAMS;

static char appName[OBJECT_NAME_LEN + 1];
static char fileName[OBJECT_FILE_NAME_LEN + 1];
static const char timeToCall[] = "Time to call\nFrom";
static const char idleMsg[] = "\nPlease Insert\nA Smart Card...";
static const char szDate[] = "Date:%.2s/%.2s/%.2s  %.2s:%.2s\n";

T_GL_HGRAPHIC_LIB gGoalGraphicLibInstance = NULL;

/**
 * Ask application to define its working environment, Manager will select
 *  common parameters set and adapt its internal processing.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O)
 *                          - application_type: TYP_CARTE (French Bank)
 *                                              TYP_HEALTH(French Health)
 *                                              TYP_EXPORT (Export)
 *                          - mask:  Key "F" 031 -> Parameters initialization (0:absent, 1:present)
 *                          - response_number: should be incremented
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int give_your_domain(NO_SEGMENT no, void *p1, S_INITPARAMOUT *param_out)
{

    // Return application domain to Manager
    // Setting parameters initialization
    param_out->returned_state[param_out->response_number].mask = MSK_ALL_PARAM;  // Accept all
    // International domain
    param_out->returned_state[param_out->response_number].application_type = TYP_EXPORT;
    param_out->response_number++;

    return (FCT_OK);
}

/**
 * Initialize data and create disks, eventually ends interrupted transaction
 *  by returning S_TRANS_OUT.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O) Eventually ends interrupted transaction
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int after_reset(NO_SEGMENT no, void *p1, S_TRANSOUT *param_out)
{
    unsigned char chgt;
    TYPE_CHGT type;

    first_init(no, &chgt, (unsigned char *)&type); // New software loaded ?
    if (chgt == 0xFF) // Yes, just loaded with first execution
    {
        raz_init(no); // Reset downloading indicator
    }

    return FCT_OK;
}

/**
 * Report application name to Manager.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O)
 *                          - appname: Application name
 *                          - no: Application number
 *                          - response_number: should be incremented
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int is_name(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
  // Report application name to Manager cannot return the family name
  // because the T_APPNAME type used in the "is_name" function is too short to store
  // the FAMILY NAME (T_APPNAME length = 12+1 FAMILY NAME length =15+1)
  // we use the binary name instead (without extension, and whose length is 11+1)
  memset(param_out->returned_state[param_out->response_number].appname,0, sizeof(param_out->returned_state[param_out->response_number].appname));
  strncpy(param_out->returned_state[param_out->response_number].appname, fileName, sizeof(param_out->returned_state[param_out->response_number].appname) - 1);
  param_out->returned_state[param_out->response_number].no_appli = no;
  param_out->response_number++;

  return (FCT_OK);
}

/**
 * Report application state initialize or not to Manager.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O)
 *                          - response: REP_OK (Initialized)
 *                                      REP_KO (Not initialized)
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int is_state(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    int ret;

    // Return application state
    param_out->returned_state[param_out->response_number].state.response = REP_OK;
    ret = is_name(no, PT_NULL, param_out);

    return (ret);
}

/**
 * Allows the application to display its idle message when Manager goes back
 *  to idle (the application should have the higher priority).
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int idle_message(NO_SEGMENT no, void *p1, void *p2)
{
       int x = 0;   // time value, it can be customized by developer according to the use case
       int y = 10;  // time value, it can be customized by developer according to the use case

       Telium_File_t *hDsp;

       T_GL_HWIDGET GM_Tab_Gw;
       T_GL_HWIDGET label;

       hDsp = Telium_Fopen("DISPLAY", "w*");

       GM_Tab_Gw = GL_Window_Create(gGoalGraphicLibInstance);
       label     = GL_Label_Create(GM_Tab_Gw);

       GL_Widget_SetText(label, idleMsg);
       GL_Widget_SetBackAlign(label, GL_ALIGN_CENTER);
       GL_Widget_SetFontScale(label, GL_SCALE_MEDIUM);

       do
       {
          GL_Window_Dispatch(GM_Tab_Gw, x); // display the message

          if (Telium_Ttestall(TIMER, y) == TIMER)
          {
                break; // TIMER event has been received from the Telium Manager
          }
       }
       while(1);

       GL_Widget_Destroy(GM_Tab_Gw);

       Telium_Fclose(hDsp);

       return FCT_OK;
}

/**
 * It's activated when pressing on "F" key to select the right application
 *  to go on menu.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 *
 * \note Other prototype variant 'int more_function_ext(NO_SEGMENT no, S_ETATOUT *in, void *out)'
 *       can be used with INCENDO.
 *       This other prototype is used if the application manages more than one application name.
 *       The 'S_ETATOUT' structure allows to know the name selected by the user after pressing the "F" key.
 *       This new prototype can be used with SDK version >= 6.5.
 */
int more_function(NO_SEGMENT no, void *p1, void *p2)
{
    menuGoalDisplay();

    return FCT_OK;
}

/**
 * It's activated when key is pressed and terminal is in idle mode.
 * \param    noappli
 * \param    key_in (I-)
 *                       - keycode: Key pressed.
 * \param    key_out (-O)
 *                       - keycode: Key pressed, new key, 0=disable.
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int keyboard_event(NO_SEGMENT noappli, S_KEY *key_in, S_KEY *key_out)
{
    // Keyboard management
    switch (key_in->keycode)
    {
    case N0:
    case N1:
    case N2:
    case N3:
    case N4:
    case N5:
    case N6:
    case N7:
    case N8:
    case N9:
    case T_VAL:
    case T_POINT:
        key_out->keycode = 0; // Inhibit these keys to Manager for International domain
        break;
    case F1:
    case F2:
    case F3:
    case F4:
    case T_CORR:
    case T_ANN:
    case NAVI_CLEAR:
    case NAVI_OK:
    case UP:
    case DOWN:
    case T_F:                               // do not filter F key and return the same key !
        key_out->keycode=key_in->keycode;   // Return the same key value for keys above !
        break;
    default:
        key_out->keycode=key_in->keycode;
        break;
    }

    return (FCT_OK);
}

/**
 * It's activated on "F" key: Consultation->State.
 *  To print terminal content.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int state(NO_SEGMENT no, void *p1, void *p2)
{
    Telium_Date_t date;
    object_info_t infos;
    Telium_File_t *hPrinter;

    // Print application info
    ObjectGetInfo(OBJECT_TYPE_APPLI, no, &infos); // Retrieve application info

    hPrinter = Telium_Fopen("PRINTER", "w-*"); // Open printer driver
    if (hPrinter != NULL)
    {
        Telium_Pprintf("\x1b""E%s\n""\x1b""F", appName); // Print application name
        Telium_Pprintf("         STATE         \n"
                "Application used as\n"
                "IngeDev Template\n\n");
        Telium_Read_date(&date); // Print date and time
        Telium_Pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);
        Telium_Pprintf("File    : %s\n", infos.file_name); // Print application file name
        Telium_Pprintf("CRC     : %04x\n", infos.crc); // Print application CRC
        Telium_Ttestall(PRINTER, 0);

        Telium_Fclose(hPrinter); // Close printer driver
    }

    return FCT_OK;
}

/**
 * It's activated on "F" key: Consultation->Transactions.
 *  To print transactions total receipt.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int consult(NO_SEGMENT no, void *p1, void *p2)
{
    Telium_Date_t date;
    Telium_File_t *hPrinter;

    // Print daily totals
    hPrinter = Telium_Fopen("PRINTER", "w-*"); // Open printer driver
    if (hPrinter != NULL)
    {
        Telium_Pprintf("\x1b""E%s\n""\x1b""F", appName); // Print application name
        Telium_Pprintf("        CONSULT        \n"
                "Print daily totals here\n"
                "Number of Debit/Credit \n"
                "Totals of Debit/Credit \n"
                "Number of Cancel\n\n");
        Telium_Read_date(&date); // Print date and time
        Telium_Pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);

        Telium_Ttestall(PRINTER, 3*100);
        Telium_Fclose(hPrinter); // Close printer driver
    }

    return FCT_OK;
}

/**
 * It's activated on "F" key: Consultation->Call->Planning of Call.
 *  To print call schedule receipt.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int mcall(NO_SEGMENT no, void *p1, void *p2)
{
    Telium_Date_t date;
    Telium_File_t *hPrinter;

    // Print call schedule
    hPrinter = Telium_Fopen("PRINTER", "w-*"); // Open printer driver
    if (hPrinter != NULL)
    {
        Telium_Pprintf("\x1b""E%s\n""\x1b""F", appName); // Print application name
        Telium_Pprintf("         MCALL         \n"
                "Planning of call here  \n"
                "Time release batch     \n"
                "Time loading parameters\n"
                "Time loading hotlist\n\n");
        Telium_Read_date(&date); // Print date and time
        Telium_Pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);

        Telium_Ttestall(PRINTER, 3*100);
        Telium_Fclose(hPrinter); // Close printer driver
    }

    return FCT_OK;
}

/**
 * Do you need the peripherals at the next call of time_function()?.
 *  It's call every minute.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O)
 *                          - response: REP_OK (Manager closes all peripherals)
 *                                      REP_KO (Manager keeps all peripherals opened)
 *
 * \return is_name result
 *
 * \see sdk_tplus.h
 */
int is_time_function(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    int iRet;

    // Peripherals needed?
    param_out->returned_state[param_out->response_number].state.response = REP_OK;
    iRet = is_name(no, PT_NULL, param_out);

    return iRet;
}

/**
 * Allow application to execute its own periodical process.
 *  It's call every minute.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int time_function(NO_SEGMENT no, void *p1, void *p2)
{
	char tcDisplay[40];

    // Periodical function in progress
	sprintf(tcDisplay, "%s %s", timeToCall, appName);
    GL_Dialog_Message(gGoalGraphicLibInstance, appName, tcDisplay,
                      GL_ICON_NONE, GL_BUTTON_NONE, 2 * GL_TIME_SECOND);

    return (FCT_OK);
}

/**
 * It's activated on "F" key: Initialization->Parameters->List.
 *  Each time Manager wants to change its own parameters.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O)
 *                          - mask: Key "F" 031 -> Parameters modification (0:accepting, 1:refusing)
 *
 * \return is_name result
 *
 * \see sdk_tplus.h
 */
int is_change_init(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    S_ETATOUT etatout;
    int iRet;
    memcpy(&etatout, param_out, sizeof(etatout));

    // accept all
    etatout.returned_state[etatout.response_number].state.mask = 0;
    memcpy(param_out, &etatout, sizeof(etatout));
    iRet = is_name(no, PT_NULL, param_out);

    return iRet;
}

/**
 * It's activated on "F" key: Initialization->Parameters->List.
 *  Each time Manager changed its own parameters.
 * \param    noappli (I-)
 * \param    param_in (I-)
 *                         - mask: Key "F" 031 -> Parameters modification (0:not modified, 1:modified)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int modif_param(NO_SEGMENT noappli, S_MODIF_P *param_in, void *p2)
{
    S_MODIF_P param_changed;
    char tcDisplay[32];

    memcpy(&param_changed, param_in, sizeof(param_changed));
    sprintf(tcDisplay, "MODIF_PARAM\n%04x", (int)param_changed.etatout.returned_state[0].state.mask);
    GL_Dialog_Message(gGoalGraphicLibInstance, appName, tcDisplay,
                      GL_ICON_NONE, GL_BUTTON_NONE, 2 * GL_TIME_SECOND);

    return (FCT_OK);
}

/**
 * It's activated each time Manager wants to run a downloading session (local or remote).
 *  "F" key: Evolution->Load->Local or Evolution->Remote Load
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O)
 *                          - response: REP_OK (application authorizes donwloading process)
 *                                      REP_KO (application refuses any downloading process)
 *
 * \return is_name result
 *
 * \see sdk_tplus.h
 */
int is_evol_pg(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    int iRet;

    // Downloading process allowed?
    param_out->returned_state[param_out->response_number].state.response = REP_OK;
    iRet = is_name(no, PT_NULL, param_out);

    return iRet;
}

/**
 * It's activated each time Manager wants to delete an application.
 *  "F" key: Deletion
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O)
 *                          - response: DEL_YES (application authorizes deletion process)
 *                                      DEL_NO (application refuses any deletion process)
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int is_delete(NO_SEGMENT no, void *p1, S_DELETE *param_out)
{
    // Deletion process allowed?
    param_out->deleting = DEL_YES;

    return (FCT_OK);
}

/**
 * Manager reports parameters file received from LLT.
 *  It's activated upon reception of a parameter file by the manager.
 * \param    no (-I)
 * \param    param_in (I-)
 *                         - volume_name: SYSTEM (File loaded in CFS)
 *                                        HOST (File loaded in DFS).
 *                         - file_name: Application file name
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int file_received(NO_SEGMENT no, S_FILE *param_in, void *p2)
{
    Telium_File_t *prt;
    S_FS_PARAM_CREATE ParamCreat;
    int Ret;
    char Dir_File[25];
    char Dir_Label[25];
    int len;
    char rsp[256];
    S_FS_FILE *pFile;

    // Print parameter file received
    prt = Telium_Fopen("PRINTER", "w-"); // Open printer driver
    Telium_Pprintf("\x1b""E%s\n""\x1b""F", appName);
    Telium_Pprintf("File Received :\n/%s/%s\n", param_in->volume_name, param_in->file_name);
    Telium_Ttestall(PRINTER, 0); // Print volume+file_name

    memclr(Dir_File,sizeof(Dir_File));
    memclr(Dir_Label,sizeof(Dir_Label));

    sprintf(Dir_Label, "/%s", param_in->volume_name);
    ParamCreat.Mode = FS_WRITEONCE;
    Ret = FS_mount(Dir_Label, &ParamCreat.Mode);
    if (Ret == FS_OK)
    {
        sprintf(Dir_File, "/%s/%s", param_in->volume_name, param_in->file_name);
        pFile = FS_open(Dir_File, "r"); // The file can be open at this stage

        // Eventually read the file and get parameters
        len = FS_length(pFile); // File length in bytes
        if (len > sizeof(rsp))
        {
            len = sizeof(rsp);
        }
        FS_read(rsp, len, 1, pFile); // Read from file

        FS_close(pFile); // Close the file
        FS_unmount(Dir_Label); // Cannot be deleted as it is located in system disk
    }

    Telium_Pprintf("%s\n", rsp);

    Telium_Fclose(prt); // Close printer driver

    return (FCT_OK);
}

/**
 * Inter application messaging.
 *  It's activated each time Manager received a message in its mailbox for this application.
 * \param    no (-I)
 * \param    param_in (I-)
 *                         - sender: Sender ID
 *                         - receiver: Receiver ID
 *                         - type: IAM type
 *                         - length: Message length
 *                         - value: Message received
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int message_received(NO_SEGMENT no, S_MESSAGE_IAM *param_in, void *p2)
{
    Telium_File_t *prt;

    // Print message received from application 2
    prt = Telium_Fopen("PRINTER", "w-"); // Open printer driver
    Telium_Pprintf("\x1b""E%s\n""\x1b""F", appName);
    Telium_Pprintf("Message IAM :\n");
    Telium_Pprintf("S:%04X R:%04X\n", param_in->sender, param_in->receiver); // USER2 to TEMPLATE
    Telium_Pprintf("IAM Type : %04X \n\n", param_in->type);

    Telium_Pprintf("%s\n\n\n\n\n\n", param_in->value); // Print the message received
    Telium_Ttestall(PRINTER, 2*100);
    Telium_Fclose(prt); // Close printer driver

    return (FCT_OK);
}

/**
 * It's activated when a card is inserted, swiped or manually entry.
 * Ask the application if the card need a specific processing.
 * \param    no (-I)
 * \param    param_in (-I)
 * \param    param_out (-O)
 *                          - response: REP_OK (card processing)
 *                                      REP_KO (no card processing)
 *  Only one application wants to process the card, manager calls CARD_INSIDE entry.
 *  More application wants to process the card, manager asks for card removal.
 *  If no application wants to process the card, manager goes on with selection process.
 *
 * \return is_name result
 *
 * \see sdk_tplus.h
 */
int is_card_specific(NO_SEGMENT no, S_TRANSIN *param_in, S_ETATOUT *param_out)
{
    int iRet;

    // Return application state
    param_out->returned_state[param_out->response_number].state.response = REP_KO;
    iRet = is_name(no, PT_NULL, param_out);

    return iRet;
}

/**
 * It's activated when an application has chosen to treat this card has specific.
 * The transaction is done here.
 * \param    no (-I)
 * \param    param_in (-I)
 * \param    param_out (-O)
 *                          - rc_payment: PAY_OK (Transaction done)
 *                                        PAY_KO (Transaction rejected)
 *  If an application returns STOP, polling is stopped and manager asks for card removal.
 *  The application is in charge to ask for amount and currency if needed.
 *
 * \return STOP: Card accepted and transaction process done, polling is stop.
 *         FCT_OK: Card refused and poll the next application.
 *
 * \see sdk_tplus.h
 */
int card_inside(NO_SEGMENT no, S_TRANSIN *param_in, S_TRANSOUT *param_out)
{
    bool card_accepted = TRUE;

    if (card_accepted)
    {
        // Return transaction status
        param_out->rc_payment = PAY_OK; // Transaction done, polling is stop
        return (STOP);
    }
    else
    {
        return (FCT_OK); // Card refused, poll the next application
    }
}

/**
 * Ask application to recognize the magnetic, smart or manually card in order to be
 * a candidate.
 * \param    no (-I)
 * \param    param_in (-I)
 * \param    param_out (-O)
 *                          - cardappnumber: 1 = Card accepted
 *                                           0 = Card rejected
 *                          - cardapp: CARD_PROCESSED (low priority)
 *                                     CARD_RECOGNIZED (medium priority)
 *                                     CARD_PRIORITY (high priority)
 *                          - appname: Application name
 *                          - no: Application number
 *                          - response_number: should be incremented
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int is_for_you_after(NO_SEGMENT no, S_TRANSIN *param_in, S_CARDOUT *param_out)
{

    // case of chip card
    if (param_in->support == CHIP_SUPPORT)
    {
        if(param_in->power_on_result == 0)
        {
            // accept this card
            param_out->returned_state[param_out->response_number].cardappnumber = 1;
            param_out->returned_state[param_out->response_number].cardapp[0].priority = CARD_PROCESSED;
        }
        else
        {
            // reject the card
            param_out->returned_state[param_out->response_number].cardappnumber = 0;
        }
    }

    // case of stripe 2 card
    if (param_in->support == TRACK2_SUPPORT)
    {
        // accept this card
        param_out->returned_state[param_out->response_number].cardappnumber = 1;
        param_out->returned_state[param_out->response_number].cardapp[0].priority = CARD_PRIORITY;
    }

    // case of Card Number Manual entry
    if (param_in->support == OPERATOR_SUPPORT)
    {
        // accept this card
        param_out->returned_state[param_out->response_number].cardappnumber = 1;
        param_out->returned_state[param_out->response_number].cardapp[0].priority = CARD_PRIORITY;
    }

    // give my application name
    strcpy(param_out->returned_state[param_out->response_number].appname, appName);
    // give my application number
    param_out->returned_state[param_out->response_number].no_appli = no;
    // give my card name
    strcpy(param_out->returned_state[param_out->response_number].cardapp[0].cardappname, "Template");
    // increment the response number
    param_out->response_number++;

    return (FCT_OK);
}

/**
 * Process a non EMV chip card or a magnetic card or manual entry transaction.
 * \param    no (-I)
 * \param    param_in (-I)
 * \param    param_out (-O)
 *                          - rc_payment: PAY_OK (Transaction done)
 *                                        PAY_KO (Transaction rejected)
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int debit_non_emv(NO_SEGMENT no, S_TRANSIN * param_in, S_TRANSOUT * param_out)
{
    Telium_File_t *prt;
    int i;

    prt = Telium_Fopen("PRINTER", "w-");

    // case of chip card
    if (param_in->support == CHIP_SUPPORT)
    {
        Telium_Pprintf("\x1b""E%s\n""\x1b""F", appName);
        if (param_in->historical_bytes.length != 0)
        {
            Telium_Pprintf("Atr:\n");
            for (i=0; i<param_in->historical_bytes.length; i++)
            {
                Telium_Pprintf("%02X ", param_in->historical_bytes.historic[i]);
            }
        }
        else
        {
            Telium_Pprintf("Synchronous card\n");
            Telium_Pprintf("or Chip mute\n");
        }
        Telium_Pprintf("\n\n\n\n\n\n");
    }

    // case of stripe 2 card
    if (param_in->support == TRACK2_SUPPORT)
    {
        Telium_Pprintf("\x1b""E%s\n""\x1b""F", appName);
        Telium_Pprintf("Track2:\n%s\n\n\n\n\n\n", param_in->track2);
    }

    // case of Card Number Manual entry
    if (param_in->support == OPERATOR_SUPPORT)
    {
        Telium_Pprintf("\x1b""E%s\n""\x1b""F", appName);
        Telium_Pprintf("Manual Entry:\n%s\n\n\n\n\n\n", param_in->track2);
    }

    Telium_Ttestall(PRINTER, 2*100);
    Telium_Fclose(prt);

    param_out->noappli = no; // Return application number
    param_out->rc_payment = PAY_OK; // Transaction done

    return (FCT_OK);
}

/**
 *  allow registering an application with advanced HMI interface layers
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int give_your_specific_context (NO_SEGMENT no,void * p, S_SPECIFIC_CONTEXT *param_out ){

	// Initialise the output parameter
	memset(&param_out->returned_state[param_out->response_number], 0, sizeof(param_out->returned_state[param_out->response_number]));
	// The name of the resource file
	strcpy(param_out->returned_state[param_out->response_number].appname,    _ING_APPLI_DATA_FILE_BINARY_NAME);
	param_out->returned_state[param_out->response_number].no_appli = no;
	param_out->returned_state[param_out->response_number].mask = 0;
	param_out->returned_state[param_out->response_number].type = 0;
	param_out->returned_state[param_out->response_number].support = 0;
	param_out->returned_state[param_out->response_number].cam = 0;
	// The application is CGUI compliant to display an icon in the telium manager main menu
	param_out->returned_state[param_out->response_number].cgui = CGUI_MASK;
	param_out->response_number++;

	return FCT_OK;
}


/**
 * Services registration and priority.
 * For all services except idle_message, priority => 0x00 highest and 0xFF lowest
 * For idle_message, priority => 0x00 lowest 0xFF highest
 * \param    AppliNum (-I)
 * \param    p1 (-I)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk_tplus.h
 */
int give_interface(unsigned short AppliNum, void *p1, void *p2)
{
    int i;

    for(i = 0; i < (int)(sizeof(Services) / sizeof(Services[0])); i++)
        Services[i].appli_id = AppliNum;

    Telium_ServiceRegister((sizeof(Services) / sizeof(Services[0])), Services);

    return FCT_OK;
}

#ifdef __cplusplus
extern "C"
{
#endif

/**
 * entry() is called by the OS for recording services and opening DLL(s).
 * The RegisteryPowerFailure() can also be moved to entry().
 *
 * \see sdk_tplus.h
 */
void entry(void)
{
  object_info_t info;
  char * indexExt;

  // Recording services
  ObjectGetInfo(OBJECT_TYPE_APPLI, ApplicationGetCurrent(), &info);
  give_interface(info.application_type, NULL, NULL);

  // Creates an instance of the graphics library.
  // This creation takes some time. To be quicker it can also be instantiated only once in application's life
  if(gGoalGraphicLibInstance == NULL) {
	    gGoalGraphicLibInstance = GL_GraphicLib_Create();
  }

  memcpy(appName, info.name, OBJECT_NAME_LEN);
  memcpy(fileName, info.file_name, OBJECT_FILE_NAME_LEN);
  fileName[OBJECT_FILE_NAME_LEN] = '\0';
  appName[OBJECT_NAME_LEN] = '\0';

  // Manager looks for application icon whose name must be the same as the string given to the "is_name" function
  // FAMILY NAME cannot be used because the T_APPNAME type used in is_name function is too short to store FAMILY NAME (T_APPNAME length = 12+1 FAMILY NAME length =15+1)
  // Binary name is used instead. "info.file_name" contains the binary name with the file extension
  // (e.g. ABCDEFG.AGN). Extension must be removed in the name returned by the 'is_name' function.
  indexExt = strstr(fileName, ".");
  if(indexExt != NULL) {
    *indexExt = '\0';
  }
}

#ifdef __cplusplus
}
#endif
